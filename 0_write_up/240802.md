
# `12865` : 평범한 배낭 (냅색 문제)

다음에 풀어볼 `greedy algorithm`을 사용하여 1. 무게가 작은 순으로 넣어보거나, 2. 가치가 큰 순으로 넣어봐도 가치합의 최댓값을 항상 구할 수 있는 것이 아니기 때문에,

`DP`를 사용하여 테이블에 **모든 경우의 수**를 다 구해봐야 한다. `DP`는 다시 한번 정리하면 `Space Complexity`를 희생하여 `Time Complexity`를 향상시키는 방법이기도 하다.

**항상 뭔가 테이블을 정의하기 힘들 때는 모든 경우의 수를 파악할 수 있는 매트릭스를 한번 떠올려서 값을 채워 넣어보며 규칙을 파악해보자**

## 풀이 방법

1. 테이블 정의하기 

- `dp[i][j]` : `i`번째로 입력 받은 물건을 가방의 `limit`이 `j`인 경우 가방에 넣을 수 있는 가치합의 최댓값

- 최댓값으로 구해야, 점화식에서 바로 이전 `index`인 `i - 1`에만 접근해도 누적해서 모든 경우의 수를 파악할 수 있음

2. 점화식 찾기

    1. `i`번째 물건의 무게가 가방의 `limit`인 `j`보다 큰 경우, 해당 물건을 가방에 넣을 수 없기 때문에 `i - 1`번째에 누적된 값을 그대로 가져오면 됨\
    `dp[i][j] = dp[i - 1][j];`

    2. `i`번째 물건의 무게가 가방의 `limit`인 `j`보다 작거나 같은 경우, 해당 물건을 가방에 넣을 수 있고 남은 가방 무게에 `i - 1`번째에 누적된 가치합만큼을 더해줄 수 있음\
    여기서, 무조건 가방의 무게와 가치가 정비례하는 것이 아니므로, 최댓값을 구하기 위해 해당 `i`번째 물건을 가방에 넣지 않는 `dp[i - 1][j]`과 `max`를 통해 비교해줘야함\
    `dp[i][j] = max(dp[i - 1][j], value[i] + dp[i - 1][j - weight(i)]);`

3. 초기값 정하기

- `1-index`를 사용하고, `i - 1`에 접근하는 것이 항의 최대이므로 초기값은 이미 선언시 `0`인 `index`가 전부 초기화되어있음

## 전체 코드

```
// 각 물건을 저장된 순서에 따라 i로 접근하여, limit이 j인 경우 가치합의 최댓값을 테이블을 누적해서 탐색
for (int i = 1; i <= n; i++)
{
    for (int j = 1; j <= limit; j++)
    {
        if (weight[i] > j)           // 물건의 무게가 limit보다 큰 경우, 물건을 가방에 못 넣기 때문에 i - 1의 가치합을 그대로 가져옴
            dp[i][j] = dp[i - 1][j]; // 위쪽 선택

        else // 물건의 무게가 limit보다 작거나 같은 경우
            // 바로 위쪽과 : dp[i - 1][j]
            // 현재 물건의 가치를 더한 후 i - 1에서 현재 물건의 가치합을 뺀 상태에서의 가치합을 더한 결과를 비교 : value[i] + dp[i - 1][j - weight[i]]
            // max를 통해 가치합의 최댓값을 구해주지 않으면 매 테이블을 구하는 과정에서 i - 1만 탐색하여 구할 수 없음
            dp[i][j] = max(dp[i - 1][j], value[i] + dp[i - 1][j - weight[i]]);
    }
}

cout << dp[n][limit]; // 마지막에는 최댓값이 존재하기 때문에 res_max로 매번 찾아주지 않아도 됨
```

# `2559` : 수열

## 풀이 방법

**이번 문제는 `누적합`을 이용해야 하는 문제이다.** 

`n` 개의 온도에서 연속적인 `k`개의 온도 합을 이중 for문을 통해 구현하면 `O((n - k + 1)k)` 의 시간 복잡도가 발생한다. (`2559-TLE.cpp`)

여기서 `n <= 100,000` 이므로 시간복잡도의 최댓값이 되는 `n = 2k`인 `(100,000, 50,000)` 에서 TLE인 1초를 넘어서게 된다. (이중 for문의 경우 `n <= 5000`까지 가능)

해당 문제는 연속적인 `k` 개를 구할 때, **합을 구하는 과정에서  `for` 문에서 더해주는 `index`가 겹치기 때문에** 누적합을 통해 시간 복잡도를 `O(n)` 으로 줄일 수 있다.

1. 현재 `index`를 포함해서 이전 `k`개 만큼의 누적합을 저장하는 배열 `cum_sum`을 선언하여, 다음 `index`의 누적합을 구할 때,\
`cum_sum[i - 1]`에서 `temperature[i - k]`를 빼주고, `temperature[i]`를 더해주면 된다.

2. 그리고 매 계산마다, 온도합의 최댓값을 찾아야 하기 때문에 `res_max` 변수를 선언하여 계속 비교하여 업데이트해준다.

```
for (int i = k + 1; i <= n; i++)
{
    cum_sum[i] = temperature[i] + (cum_sum[i - 1] - temperature[i - k]);
    res_max = max(res_max, cum_sum[i]);
}
```

3. 위 과정을 수행하기 위해, 먼저 제일 처음 `k` 개 만큼의 누적합을 먼저 구해줘야 한다.

```
// 초기값 지정 : 첫번째 누적합 계산
for (int i = 1; i <= k; i++)
    cum_sum[k] += temperature[i];
```

## 전체 코드

```
// 온도 입력 받기
for (int i = 1; i <= n; i++)
    cin >> temperature[i];

// 초기값 지정 : 첫번째 누적합 계산
for (int i = 1; i <= k; i++)
    cum_sum[k] += temperature[i];

// 누적합을 계산해가며 최댓값 찾기
int res_max = cum_sum[k];
for (int i = k + 1; i <= n; i++)
{
    cum_sum[i] = temperature[i] + (cum_sum[i - 1] - temperature[i - k]);
    res_max = max(res_max, cum_sum[i]);
}

cout << res_max;
```

# `16139` : 인간-컴퓨터 상호작용

## 풀이 방법

처음에는 `문자열(str)`은 고정되어 있고, 질문으로 들어오는 `문자(ch)`는 바뀔 수 있는데, 문자도 고정되는 줄 알고 누적합을 한번만 구해서 틀렸다.

두번째는 문자가 바뀌는 것을 잘 대처해서, 문자가 들어올 때 마다 새로운 누적합을 `r` 까지 구해줬는데, 

이렇게 하면 같은 문자가 들어온 경우 이전에 구했던 누적합을 그대로 쓰면 되지만, 이용해주지 않아서 시간초과가 발생했다.

그래서 한 문자에 대해 이전에 구했던 누적합은 그대로 사용하기 위해, `모든 알파벳 소문자(ch는 소문자이기 때문)`에 대한 누적합을 저장하는 배열을 선언해주고,

동시에 해당 문자가 사용되었는지 저장하는 배열까지 선언하여, 해당 문자가 사용되었다면 바로 이전에 구했던 누적합을 이용하도록 하였고,

해당 문자가 처음 사용되면, 해당 문자를 사용했음을 표시해주고, 다음에 같은 문자에 대해 더 큰 `r`이 들어올 수도 있기 때문에 `r`까지가 아닌 `str.length()` 까지 누적합을 전부 구하도록 구현하였다.

그리고, `segfault`를 생각해야 하므로, `l == 0`인 경우 출력을 신경써주었고, `cum_sum[i][0]`은 미리 초기화해주었다.

## 전체 코드

```
string str; // 검사할 문자열
int n;      // 질문의 개수
char ch;    // 찾을 문자
int l, r;   // 범위 : [, ]

// 같은 문자열에 대해서 반복해서 검색하기 때문에 누적합 가능
// 이미 이전에 ch 문자에 대해서 누적합을 구했다면, 새로 구할 필요 없이 바로 누적합을 찾아야 TLE 발생 안함
int cum_sum[26][200000];
int prev_flag[26]; // 이전에 해당 문자가 들어왔는지 저장하는 배열

...

cin >> ch >> l >> r;

if (prev_flag[ch - 'a'] == true)
    cout << (l == 0 ? cum_sum[ch - 'a'][r] : cum_sum[ch - 'a'][r] - cum_sum[ch - 'a'][l - 1]) << '\n';

else
{
    prev_flag[ch - 'a'] = true; // 해당 문자의 누적합을 이미 구했음을 표시

    // 0-index로 해야 l, r을 파악하기 쉽기 때문에 index 0은 미리 초기화해줌
    if (str[0] == ch)
        cum_sum[ch - 'a'][0] = 1;

    for (int i = 1; i < str.length(); i++) // 다음에 같은 문자에 대해 더 큰 r이 들어올 수 있으므로 전체 문자열에 대한 누적합을 미리 구함
    {
        cum_sum[ch - 'a'][i] = cum_sum[ch - 'a'][i - 1]; // 이전 항의 누적합을 가져옴
        if (str[i] == ch)                                // 문자를 찾은 경우
            cum_sum[ch - 'a'][i]++;                      // 누적합 + 1
    }

    // l == 0 인 경우, (l - 1)은 segfault가 나기 때문에 cum_sum[r]만 출력해줘야함
    // l != 0 인 경우, l, r 번째 문자를 포함해야 하기 때문에 [r]에서 [l - 1]을 뺴줘야함
    cout << (l == 0 ? cum_sum[ch - 'a'][r] : cum_sum[ch - 'a'][r] - cum_sum[ch - 'a'][l - 1]) << '\n';
}
```