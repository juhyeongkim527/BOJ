# `2579` : 계단 오르기

## 풀이 방법

처음에 테이블을 정의할 때, `dp[i]`를 `i` 번째 계단에 올라왔을 때, 점수의 최댓값으로 하였는데, 이렇게 하면 점화식을 제대로 구해낼 수가 없다.\
그 이유는, `dp[i]`의 최댓값을 구했다고 해서, `dp[i+1]`이나, `dp[i+2]`에서도 이전 값을 통해 최댓값을 구할 수 없기 때문이다.

더 자세히 예시를 들면, 세 계단을 연속으로 올라갈 수 없기 때문에 `50 100 10 10 100 1`이 주어지는 상황에 `dp[2] = 150`이지만, \
`dp[3]`은 세 계단을 연속적으로 오르지 못해서 `dp[2]`로 구하는게 아니라 `dp[2]`로 한번에 두계단 점프한 값에 자신의 점수를 더해야 하기 때문이다.

위 방식으로 구하면 `dp[3] = 60`이 되지만, 실제 최댓값은 `dp[3] = 100 + 10 = 110`이다.

따라서, 한 계단 `i` 에서 최댓값을 하나만 저장하는 것이 아닌 아래와 같이 **2차원 배열로, 계단을 오른 모든 방법에 대한 최댓값을 저장**할 수 있도록 테이블을 정의해야한다.

1. 테이블 정의하기

- `dp[i][j]` : `i` 번째 계단에서, 현재까지 `j`번 연속 계단을 올라왔을 때 점수의 최댓값 (계단은 연속 2번까지 올라갈 수 있기 때문에, `j`는 `1`과 `2`를 가질 수 있음)

2. 점화식 찾기

- 현재 계단을 연속적으로 `1`번 올라간 상태인 경우, 한 계단을 뛰어 넘어서 한번에 두 계단을 올라온 경우이므로, `i - 2` 번째 계단에서 두 `j` 값 중 최댓값에 `score[i]`를 더하면 된다.
    - `dp[i][1] = max(dp[i - 2][1], dp[i - 2][2]) + score[i];`

- 현재 계단을 연속적으로 `2`번 올라간 상태인 경우, 무조건 이전 `i - 1` 번째 계단에서 한 계단을 연속적으로 올라온 경우이므로, `dp[i - 1][1]`에 `score[i]`를 더하면 된다.
    - `dp[i][2] = dp[i - 1][1] + score[i];`

3. 초기값 정하기

- `1` 번째 계단과, `2`번째 계단까지는 반복문 없이 바로 `j = 1`과 `j = 2`를 정할 수 있기 때문에 초기값을 아래와 같이 설정해주고, `i - 2`를 접근하므로 `i = 3`부터 반복문을 순회한다.\
(`dp[1][0]`은 선언과 함께 `0`으로 미리 초기화 해두었음)

```
dp[1][1] = score[1];
dp[2][1] = score[2];
dp[2][2] = score[1] + score[2];
```

## 전체 코드

- 배열으로 전역 변수로 선언하면, 모든 값을 명시적으로 초기화해주지 않아도 `0` 으로 초기화되지만, 지역 변수로 선언하는 경우 명시적으로 `0`으로 초기화 해줘야함\
(`0`이 아닌 값으로 초기화하려면 `fill` 함수를 써야함)

```
int n;
cin >> n;

// 테이블 정의 : dp[i][j]는 j만큼 연속적으로 계단을 올랐을 때, i번째 계단에 대한 점수 최댓값
// 계단 수는 300 이하에서 1-index를 쓰면서 연속으로 오른 계단의 수는 1,2가 가능하므로 [301][3]의 크기를 가짐
int dp[301][3] = {0}; // 전역변수는 선언만 해도 0으로 초기화 되지만, 지역 변수는 초기화해줘야함

// 각 계단의 점수를 저장하는 배열
int score[301];

for (int i = 1; i <= n; i++)
    cin >> score[i];

// 초기값 설정
dp[1][1] = score[1];
dp[2][1] = score[2];
dp[2][2] = score[1] + score[2];

for (int i = 3; i <= n; i++)
{
    // 지금까지 1번 계단을 연속적으로 올라간 경우는 두 계단을 뛰어 넘어간 것이므로, i - 2 번째의 최댓값중 더 큰 값에 score를 더하면 됨
    dp[i][1] = max(dp[i - 2][1], dp[i - 2][2]) + score[i];
    // 지금까지 2번 계단을 연속적으로 올라간 경우는 바로 이전 계단에서 한 계단을 연속적으로 올라간 경우
    dp[i][2] = dp[i - 1][1] + score[i];
}

cout << max(dp[n][1], dp[n][2]);
```

# `11659` : 구간 합 구하기 4

수 `N` 개가 주어졌을 때, `M`번 만큼 입력받은 `i`번째 수부터 `j`번째 수까지의 합을 출력하는 문제이다.

해당 문제를 풀기 위해서, 수 `N`개를 `M`번 입력 받을 때 마다 `i`부터 `j`번째 까지 수를 더하면 총 `O(NM)`의 시간 복잡도가 발생하므로, `N, M <= 100,000`인 상황에서는

시간 초과가 발생할 수 있기 때문에, `누적합`을 이용한 DP로 해당 문제를 풀이하여 `O(N)`의 시간 복잡도로 문제를 풀이할 수 있다.

## 풀이 방법

매번 `i`부터 `j`번째 수까지의 합을 더하는 것이 아닌, 누적합을 구해두고(`O(N)`) `j`번째까지의 누적합에서 `i - 1`번째까지의 누적합을 빼주면 `O(N) * O(1)`으로 문제를 풀이할 수 있다.

1. 테이블 정의하기

- `cum_sum[i]` : `i` 번째 수까지의 누적합

2. 점화식 찾기

- `cum_sum[i] = cum_sum[i - 1] + arr[i];`

3. 초기값 정하기

- `i = 1`일 때만, `i - 1`이 존재하지 않기 때문에 `cum_sum[1] = arr[1];` 을 해주고, `i = 2` 부터 반복문을 순회하면 된다.

## 전체 코드

```
cin >> n >> m;

for (int i = 1; i <= n; i++)
    cin >> arr[i];

cum_sum[1] = arr[1]; // 초기값 지정
for (int i = 2; i <= n; i++)
    cum_sum[i] += cum_sum[i - 1] + arr[i]; // 점화식

for (int i = 0; i < m; i++)
{
    cin >> start_ >> end_;
    cout << cum_sum[end_] - cum_sum[start_ - 1] << '\n';
}
```

# `9461` : 파도반 수열

## 풀이 방법

이번 문제에서, 마치 피보나치 수열처럼 이전 값이 누적되어 더해지는데 `int`로 `dp`를 선언하면 **범위를 넘어서서 `long`으로 해줘야 틀리지 않음**

1. 테이블 정의하기

- 문제에 주어진 대로 `dp[i]`는 `i`번째 추가되는 정삼각형의 변의 길이

2. 점화식 찾기 : **각 인덱스의 점화식을 나열해봐야, 규칙을 나열해봐야 알 수 있음**

- `i = 1 ~ 5`는 규칙성을 찾기 힘들지만, `i = 6` 부터 `dp[i] = dp[i - 5] + dp[i - 1]`이라는 규칙성이 존재하게 됨

3. 초기값 설정 

- 앞에서 봤듯이 규칙성이 없는 `i = 1 ~ 5`의 값을 초기값으로 정하고 `i = 6`부터 반복문으로 모든 테이블을 미리 채워두면 됨

## 전체 코드

```
// 초기값 정하기
dp[1] = 1;
dp[2] = 1;
dp[3] = 1;
dp[4] = 2;
dp[5] = 2;

// 점화식 찾기
for (int i = 6; i <= 100; i++)
{
    if (2 <= i % 12 && i % 12 <= 4)
        dp[i] = dp[i - 1];
    dp[i] = dp[i - 5] + dp[i - 1];
}

int input;
while (n--)
{
    cin >> input;
    cout << dp[input] << '\n';
}
```

# `24416` : 알고리즘 수업 - 피보나치 수 1

`recursion`을 사용한 피보나치 함수와, `Dynamic Programming`을 사용한 피보나치 함수의 실행 속도 차이를 비교하는 문제였음.

- **재귀의 장점은 직관성과 간결성이고, DP의 장점은 빠른 시간 복잡도와 적은 공간 복잡도임**

- `recursion`을 사용하면, 아래의 코드가 계속 겹쳐서 호출되므로, 매우 많이 코드가 실행되서 시간 복잡도가 `O(n)`이 아닌 `O(1.618 * n)`에 근사하게됨

```
if (n == 1 || n == 2)
{
    code1_cnt++;
    return 1; // code 1
}
```

예를 들어, `fib(6)` = `fib(5) + fib(4)` = `{fib(4) + fib(3)} + {fib(3) + fib(2)}` = `{fib(3) + fib(2)} + {fib(2) + 1} + {fib(2) + 1} + 1` ...
 
- 대신, `DP`를 사용하면, 입력으로 받은 `n` 만큼만 연산을 진행해서 `O(n)`의 시간이 들어서 시간이 매우 짧아짐

```
for (int i = 3; i <= n; i++)
{
    code2_cnt++;
    f[i] = f[i - 1] + f[i - 2]; // code2
}
```