# `2156` : 포도주 시식

## `2156-1.cpp` 풀이 방법

예전에 풀었던 계단 오르기 문제와 달리, 무조건 **한칸 또는 두칸씩 이동할 수 있는게 아니라 3칸 이상도 이동할 수 있기 때문에** 완전히 같은 논리로 문제를 풀면 틀림

반례 : `j = 1, j = 2` 까지만 비교하면 `[100, 100, 1, 1, 100, 100]` 이 입력 됬을 때, `1, 2, 5, 6` 번째를 선택할 수 없기 때문

따라서 연속으로 3잔을 마시지 않으면서도, 3칸 이상 이동하기 위해서는 `j = 0` 까지 고려해서 마시지 않고 계속 이동하는 것

1. 테이블 정의하기

- `dp[i][j]` : `i`번째 포도주 잔을 `j`번 연속 마셨을 때의 최댓값 

- 연속으로 놓여 있는 3잔을 마실 수 없으면서, 한번에 이동가능한 크기가 제한되어 있지 않기 때문에 `j = 0, 1, 2`가 가능함
    - `j = 0` : 해당 `i`의 포도주를 마시지 않고 그대로 이동한 것
    - `j = 1` : 해당 `i`의 포도주를 처음으로 마신 것
    - `j = 2` : 해당 `i`의 포도주를 바로 이전 포도주와 이어서 마신 것

2. 점화식 찾기

- `j = 0` 인 경우, `i - 1`의 모든 `i` 중 최댓값을 찾고 `arr[i]`를 더하지 않으면 된다.
    - `dp[i][0] = max({dp[i - 1][0], dp[i - 1][1], dp[i - 1][2]});`

- `j = 1` 인 경우, `i - 1`의 모든 `j = 0`과, `i - 2`의 `j = 1, 2` 중 최댓값을 찾고 `arr[i]`를 더해주면 된다.
    - `dp[i][1] = max({dp[i - 1][0], dp[i - 2][1], dp[i - 2][2]}) + arr[i];`
    
    - 생각해보면, `dp[i - 1][0]`에서 나머지 2개 항을 이미 다 계산해줬기 때문에 아래처럼 하면 됨\
    `dp[i][1] = dp[i - 1][0] + arr[i];`

- `j = 2` 인 경우, `i - 1`의 `j = 1`에 `arr[i]`를 더해주면 된다.
    - `dp[i][2] = dp[i - 1][1] + arr[i];`       

- 계단 오르기와 달리 마지막 포도주를 꼭 마실 필요가 없기 때문에 `res_max`로 `j` 값 중 최대를 찾고, 계속 `i`를 순회하며 `res_max`와 비교하도록 한다.\
(`j = 0`을 생각해내기 전에 `res_max`를 썼는데, 사실 `j = 0`이 있으면 `res_max` 없이 마지막에 `j = 0, 1, 2`중 찾아주면 됨)

3. 초기값 정하기

- `dp[1][1]` 만 찾아주면 `i = 2` 부터 바로 모든 값을 찾을 수 있다. (`i = 0`일 때는 어쩌피 0으로 초기화 되있고, `[1][0]`, `[1][2]`도 0으로 초기화 되있기 때문)

## 전체 코드

```
// 초기값 설정 : [1][0]과 [1][2]는 이미 선언과 동시에 0으로 초기화
dp[1][1] = arr[1];
// res_max = dp[1][1];

for (int i = 2; i <= n; i++)
{
    // 점화식 찾기
    dp[i][0] = max({dp[i - 1][0], dp[i - 1][1], dp[i - 1][2]}); // i번째 포도주를 먹지 않고 그대로 올라온 것 (꼭 2칸만 뛰어 넘을 필요가 없기 때문)
    // dp[i][1] = max({dp[i - 1][0], dp[i - 2][1], dp[i - 2][2]}) + arr[i];
    dp[i][1] = dp[i - 1][0] + arr[i]; // 1번 연속으로 마셨을 때는 2단계 뛰어넘어서 마셔야 하기 때문
    dp[i][2] = dp[i - 1][1] + arr[i]; // 2번 연속으로 마셨을 때는 1단계 이전의 포도주에서 연속으로 마셔야 하기 때문

    // res_max = max({res_max, dp[i][0], dp[i][1], dp[i][2]}); // 마지막 포도주를 마실 필요가 없기 때문에 max를 따로 찾아줘야함
}

// cout << res_max;
cout << max({dp[n][0], dp[n][1], dp[n][2]});
```

## `2156-2.cpp` 풀이 방법 및 전체 코드 : 논리는 같지만, 2차원 배열을 1차원 배열로 축소 

```
// 초기값 설정
dp[1] = arr[1];
dp[2] = arr[1] + arr[2];

for (int i = 3; i <= n; i++)
    // 점화식 찾기
    dp[i] = max({dp[i - 1], dp[i - 3] + arr[i - 1] + arr[i], dp[i - 2] + arr[i]});

cout << dp[n];
```

# `11053` : 가장 긴 증가하는 부분 수열

- 테이블을 꼭 찾고자 하는 최댓값이나 최솟값을 저장하도록 하지 않아도 됨, 테이블은 중복 계산을 피하기 위해 현재 `i`에서의 상태만 저장하는 것으로 생각해도 됨

- 시간 제한이 `1초` 인 경우 `n <= 5000` 이면 이중 for문을 도는 `O(n^2)` 까지 허용

## 풀이 방법

1. 테이블 정의하기

- `dp[i]` : `i` 번째 수를 수열의 끝으로 하는 부분 수열의 길이

이전에 푼 대부분 문제에서는 최댓값이나 최솟값을 구할 때, `i`의 상태와 상관 없이 `dp[i]` 를 `i` 번째에 왔을 때 최댓값이나 최솟값으로 뒀지만,

이번 문제에서는 `dp[i]`를 최댓값이 아닌 `i`번째 값을 수열의 끝으로 하는 부분 수열의 길이로 두었다.

그 이유는, `dp[i]`를 길이가 `i` 일 때 현재까지의 부분 수열의 최댓값으로 두면 `[1 2 1 2]`가 입력되는 경우, 아래의 점화식 대로 하면 마지막 `2`에서 `dp[i] = 3`으로 업데이트 되버리기 때문이다.

계단 오르기, 포도주 시식 문제는 최댓값을 찾는 과정에서, `i` 번째의 값 자체가 더해져서 많이 더할 수록 커지고, 순서가 상관 없어서 2차원 배열로 범위를 `j = 0, 1, 2`로 설정할 수 있지만, 

이번 문제의 경우 `i` 번째의 값 자체가 더해지는 것이 아닌 **순서가 중요**하며, **`i`를 이동하는 것에 완전히 제한이 없기 때문에,**

`j = 1`부터 `j = i` 까지 순회해야 해서 2차원 배열으로 `i`에서 최댓값을 저장하는 것이 아닌, `i`에서 현재 값을 저장하는 것으로 구현해야함

이번 문제가 `DP`인 이유는 테이블을 쓰지 않으면, 3중 for문을 써서 부분 수열을 찾을 때 계속 그 이전 값과 부분 수열인지 비교해야 하지만, 

`dp[i]`를 쓰면 이중 for문으로 이전 `i` 의 부분 수열 길이를 저장하고 있기 때문에 더 빠른 알고리즘을 적용할 수 있음 

2. 점화식 찾기

`i = 1` 부터 `j = i` 까지 `arr`와 `dp`를 순회하며, `arr[j] < arr[i]` 인 경우, 해당 `dp[i] = dp[j] + 1`을 해준다.

**여기서 주의할 점은 `[1 2 1 3]` 인 경우 `arr[2]`에서 `dp[4] = 3`이 됬다가, `arr[3]`에서 `dp[4] = 2`가 되버리므로, `dp[i] = max(dp[j] + 1, dp[i])`를 해줘야 한다.**

그리고, 최댓값을 구해야 하지만 `dp`는 최댓값을 저장하지 않기 때문에 매번 `i`를 순회할 때, `res_max`에 `dp[i]` 의 최댓값을 찾아준다.

```
for (int i = 1; i <= n; i++)
{
    for (int j = 1; j <= i; j++)
    {
        if (arr[j] < arr[i])
        {
            dp[i] = max(dp[j] + 1, dp[i]);
        }
    }
    res_max = max(res_max, dp[i]);
}
```

아래와 같이 마지막에 `dp`에서 `sort` 후 최댓값을 찾아도 됨

```
sort(dp, dp + n);
cout << dp[n];
```

3. 초기값 정하기

`dp[i]` 를 돌면서 `arr[j] < arr[i]`를 못 찾을 경우 `dp[i] = 1` 이 되어야 하므로, 입력을 받으며 미리 모든 `dp[i] = 1`로 초기화시켜준다.

```
for (int i = 1; i <= n; i++)
{
    cin >> arr[i];
    dp[i] = 1; // 초기값 설정 : 모든 수열은 자기 자신의 길이가 1이기 때문
}
```

## 전체 코드

```
for (int i = 1; i <= n; i++)
{
    cin >> arr[i];
    dp[i] = 1; // 초기값 설정 : 모든 수열은 자기 자신의 길이가 1이기 때문
}

for (int i = 1; i <= n; i++)
{
    for (int j = 1; j <= i; j++)
    {
        if (arr[j] < arr[i])
        {
            dp[i] = max(dp[j] + 1, dp[i]);
        }
    }
    res_max = max(res_max, dp[i]);
}

cout << res_max;

// sort(dp, dp + n);
// cout << dp[n];
```

# `11054` : 가장 긴 바이토닉 부분 수열

## 풀이 방법

수열 S가 어떤 수 Sk를 기준으로 S1 < S2 < ... Sk-1 < **Sk** > Sk+1 > ... SN-1 > SN을 만족한다면, 그 수열을 바이토닉 수열이라고 한다.

`11053`번에서 `i`번째 수를 수열의 끝으로 하는 증가하는 부분 수열을 구했기 때문에, `i`번째 수를 수열의 시작으로 하는 감소하는 부분 수열을 같은 방식으로 구하면,

`i`를 기준으로 증가하느 부분 수열의 길이와 감소하는 부분 수열의 길이를 더해서 중복되는 `i`를 생각하여 `1`을 빼주면 바이토닉 부분 수열을 구할 수 있다.

1. 테이블 정의하기

- `inc_dp[i]` : `i`번째 수를 수열의 끝점으로 하는 증가하는 수열의 길이

- `dec_dp[i]` : `i`번째 수를 수열의 시작점으로 하는 감소하는 수열의 길이

2. 점화식 찾기

아래와 같이 `inc_dp[i]` 와 `dec_dp[i]`를 이중 for문을 통해 구할 수 있다. **`dec_dp[i]`는 `i`가 시작점이어야 하고, 감소하는 부분 순열이어야 하므로 방향이 반대여야 한다.**\
(`i`를 기준으로 대칭이기 때문에 무조건 반대 방향으로 반복문을 구현해야한다.)

```
// 증가하는 부분 수열 구하기
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= i; j++)
        if (arr[i] > arr[j])
            inc_dp[i] = max(inc_dp[j] + 1, inc_dp[i]);

// 감소하는 부분 수열 구하기 (증가하는 부분 순열과 반대 방향으로 구해야 이전 테이블의 정보를 누적해서 알 수 있음)
for (int i = n; i >= 1; i--)
    for (int j = n; j >= i; j--)
        if (arr[i] > arr[j])
            dec_dp[i] = max(dec_dp[j] + 1, dec_dp[i]);
```

가장 긴 바이토닉 수열을 구하기 위해서는, `inc_dp[i] + dec_dp[i] + 1`의 최댓값을 반복문을 통해 구해주면 된다.

```
// 가장 긴 바이토닉 부분 수열의 길이를 구하기 위해서는 i에서 inc_dp와 dec_dp의 합에서 중복되는 i를 생각하여 1을 뺀 값의 최댓값을 찾아주면 됨
for (int i = 1; i <= n; i++)
    res_max = max(res_max, inc_dp[i] + dec_dp[i] - 1);
```

3. 초기값 정하기

모든 수열에서 `arr[i] > arr[j]` 를 찾지 못했을 때는 길이가 `1`이어야 하므로, 입력을 받으며 전부 `1`로 미리 초기화시켜준다.

```
for (int i = 1; i <= n; i++)
{
    cin >> arr[i];
    // 초기값 설정
    inc_dp[i] = 1;
    dec_dp[i] = 1;
}
```

## 전체 코드

```
for (int i = 1; i <= n; i++)
{
    cin >> arr[i];
    // 초기값 설정
    inc_dp[i] = 1;
    dec_dp[i] = 1;
}

// 증가하는 부분 수열 구하기
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= i; j++)
        if (arr[i] > arr[j])
            inc_dp[i] = max(inc_dp[j] + 1, inc_dp[i]);

// 감소하는 부분 수열 구하기 (증가하는 부분 순열과 반대 방향으로 구해야 이전 테이블의 정보를 누적해서 알 수 있음)
for (int i = n; i >= 1; i--)
    for (int j = n; j >= i; j--)
        if (arr[i] > arr[j])
            dec_dp[i] = max(dec_dp[j] + 1, dec_dp[i]);

// 가장 긴 바이토닉 부분 수열의 길이를 구하기 위해서는 i에서 inc_dp와 dec_dp의 합에서 중복되는 i를 생각하여 1을 뺀 값의 최댓값을 찾아주면 됨
for (int i = 1; i <= n; i++)
    res_max = max(res_max, inc_dp[i] + dec_dp[i] - 1);
```

# `2565` : 전깃줄

## 풀이 방법

전깃줄이 교차되지 않게 하려면, 오름차순으로 정렬된 한쪽 전봇대를 기준으로 반대편 전봇대가 오름차순으로 증가해야한다.

왼쪽 또는 오른쪽 전봇대를 기준으로 번호를 오름차순으로 정렬한 후, 반대 쪽에 의해 정렬된 번호들의 **가장 긴 증가하는 부분 수열**을 구하면 교차된 전깃줄을 최소로 제거한 상태를 찾을 수 있다.

왼쪽 전봇대를 기준으로 오름차순으로 정렬하기 위해 `left`를 `key`로 가지고, 오른쪽 전봇대인 `right`를 `value`로 가지는 `map`을 선언해주고,

정렬된 `value`를 `arr`에 대입하여, `arr`의 가장 긴 증가하는 수열을 구하면 된다.

`dp`를 사용하는 방법은 위의 문제들과 동일하다.

## 전체 코드

```
int left, right;
for (int i = 1; i <= n; i++)
{
    cin >> left >> right;
    line[left] = right;
    dp[i] = 1; // 초기값 설정
}

int i = 1;
for (auto it : line)
{
    arr[i] = it.second; // 정렬된 왼쪽 전봇대 번호에 의해 순서가 정해진 오른쪽 전봇대 번호를 arr에 대입
    i++;
}

// 증가하는 부분 수열의 길이 찾기
for (i = 1; i <= n; i++)
{
    for (int j = 1; j <= i; j++)
    {
        if (arr[i] > arr[j])
            dp[i] = max(dp[j] + 1, dp[i]);
    }

    res_max = max(res_max, dp[i]);
}

// 제거할 전깃줄을 출력해야 하기 때문에, 전체 전깃줄 개수에서 증가하는 부분 수열의 개수를 빼주면 제거할 전깃줄 개수가 나옴
cout << n - res_max;
```