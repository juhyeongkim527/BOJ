# `2차원 배열`을 가지는 테이블의 풀이 방법

1. 1차원 배열이 아닌 `2차원 배열`로 값을 받는 경우, 2차원 배열의 `row`와 `col`의 `모든 값`을 채워서 마지막에 구하려고 하는 값(최댓값, 최솟값 등)을 찾기.

2. 문제를 단순화해서 현재 항의 `row`에 해당하는 `i`는 `i - 1` 항과 비교하는지, `i - 2`항과 비교하는지 생각하고, \ 
현재 항의 `col`에 해당하는 `j`는 `i - 1` 항의 어떤 `j` 값과 비교하는지 규칙성 찾아서 점화식 찾기

4. 입력 받은 배열을 바로 테이블로 정의하여 바로 누적 값을 더하는 경우, `dp`에 처음에 입력을 받은 후 이후 점화식을 적용하는 과정에서 `+=`를 해주며 업데이트 해주면 됨

# `1149` : RGB거리

## 풀이 방법

문제의 조건을 살펴보면,

- `1`번 집의 색은 `2`번 집의 색과 같지 않아야 한다.

- `N`번 집의 색은 `N-1`번 집의 색과 같지 않아야 한다.

- `i`(2 ≤ i ≤ N-1)번 집의 색은 `i-1`번, `i+1`번 집의 색과 같지 않아야 한다.

해당 조건이 존재하는데, 정리해보면 결국 `i` 번째 집의 색은 `i - 1` 번째 집의 색과 다른 것만 만족하면 된다. 

(3번 조건 때문에 `i + 1` 번째 집의 색상과 연관지어서 생각하면 혼동됨, `i - 1` 번째를 선택한 것이 `i + 1`에 영향을 주지 않기 때문)

1. 테이블 정의하기 

- `dp[i][j]` : `i` 번째 집을 `j` 색상으로 칠했을 때의 비용의 최솟값 (`j`는 0부터 2까지 차례대로 R G B를 나타냄)

- 처음에 `dp[i][j]` 에 각 집의 비용을 미리 다 입력 받아주고, 점화식을 통해 누적해서 더하는 것으로 구현 (메모리 효율을 위해)

2. 점화식 찾기

- `i` 번째 집의 색상은 `i - 1` 번째 집의 색상과 달라야 하기 때문에, `dp[i][j]`에 `dp[i - 1][j]` 중 `j`와 다른 `index` 중의 최솟값을 더해주면 된다.

```
dp[i][0] += min(dp[i - 1][1], dp[i - 1][2]);
dp[i][1] += min(dp[i - 1][0], dp[i - 1][2]);
dp[i][2] += min(dp[i - 1][0], dp[i - 1][1]);
```

3. 초기값 정하기

- 명시적으로 `dp[0][0 ~ 2]`에 `0`을 대입해줘도 되지만, 전역 변수로 초기화하면 바로 `0`으로 초기화 되기 때문에 명시적으로 해줄 필요는 없음

## 전체 코드

```
for (int i = 1; i <= n; i++)
    for (int j = 0; j < 3; j++)
        cin >> dp[i][j];

// dp[0][j] 는 이미 0으로 초기화 되있기 때문에 초기값을 설정할 필요가 없음
for (int i = 1; i <= n; i++)
{
    dp[i][0] += min(dp[i - 1][1], dp[i - 1][2]);
    dp[i][1] += min(dp[i - 1][0], dp[i - 1][2]);
    dp[i][2] += min(dp[i - 1][0], dp[i - 1][1]);
}

cout << min(min(dp[n][0], dp[n][1]), dp[n][2]);
```

# `1932` : 정수 삼각형

## 풀이 방법

`1149`번의 RGB거리 문제와 같은 방식으로, **바로 이전 항인 `i - 1` 번째 값의 특정 `index` 들을 비교하며, 테이블의 모든 값을 채워나가는 방법으로 풀이할 수 있다.**

위에서 `i` 번째 줄에서, 왼쪽부터 `j` 번째 수는 `i - 1` 번의 왼쪽 대각선인 `j - 1`번째 수와 오른쪽 대각선의 `j`번째 수 중 더 큰 값을 더해주며, 현재 수를 선택했을 때의 최댓값을 찾을 수 있다.

1. 테이블 정의하기

- `dp[i][j]` : 삼각형의 맨 윗줄부터 시작하여, `i`번째 줄에서 왼쪽부터 `j`번째 수를 선택했을 때의 최댓값

- `1-index`로 지정했기 때문에 `i = j = 1`부터 반복문을 순회하며, `i - 1`이나 `j - 1` 번째 `index`가 `0`이 되어도 `segfault`가 발생하지 않고, 초기값을 설정해줄 필요도 없다.

2. 점화식 찾기

- `dp[i][j] = max(dp[i - 1][j - 1], dp[i - 1][j]);`

- 이후 마지막 줄인 `n` 번째 줄의 삼각형의 최댓값을 구하기 위해서는 `j = 1 ~ n` 을 순회하며 최댓값을 찾으면 된다.

3. 초기값 정하기

- 명시적으로 `i = 0`과 `i = 1`에서 초기화 해줘도 되지만, 
    
    - 어쩌피 `i = 0`은 `1-index`를 사용하고 전역 변수로 선언하여 `0`으로 초기화 되있고,

    - `i = 1`은 `i - 1 == 0`을 참조하면 값이 업데이트 되지 않고 그대로이기 때문에, 입력 받은 값을 그대로 쓰면 된다.

- 따라서 반복문 순회를 `i = 1`부터 해도 되고, `i = 2`부터 해도 상관 없다.

## 전체 코드

```
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= i; j++)
        cin >> dp[i][j]; // 정수 삼각형 입력

// 1-index 이므로, `i-1`에서 segfault가 발생하지 않음
for (int i = 2; i <= n; i++)
    for (int j = 1; j <= i; j++)
        dp[i][j] += max(dp[i - 1][j - 1], dp[i - 1][j]); // 점화식 찾기, i - 1 줄의 왼쪽 대각선(j-1)과 오른쪽 대각선(j) 중 큰 것을 선택

int res = 0;
for (int i = 1; i <= n; i++)
    res = max(res, dp[n][i]); // 마지막 열에서 최댓값을 선택

cout << res;
```

# `10844` : 쉬운 계단 수

## 풀이 방법

이번에도 2차원 배열으로 테이블을 정의하여, 각 자리에 올 수 있는 `0 ~ 9` 배열을 `col index`로 두고, 길이를 `row index`로 두어서 정의하면 된다.

여기서, `int overflow`를 방지하기 위해 점화식 계산마다 `1,000,000,000`으로 나눈 나머지를 출력해야 하는 것을 기억하고, `0`과 `9`의 경우를 주의해야 하는 것 파악하기

1. 테이블 정의하기

- `dp[i][j]` : 길이가 `i`인 계단 수 중, 마지막 자리 수가 `j` 인 계단 수의 개수

2. 점화식 찾기

- `i == 0` 이거나 `i == 9` 인 상황을 제외하고, 각 자리 수는 이전 자리 수와 차이가 1만큼 나면 되기 때문에,\
`dp[i][j] = (dp[i][j] + dp[i - 1][j - 1] + dp[i - 1][j + 1]) % 1000000000;` 을 해주면 된다.

- `i == 0` 이거나 `i == 9` 인 상황에서는 `i - 1`과 `i + 1`이 각각 존재하지 않기 때문에, `i + 1`과 `i - 1`만 더해주도록 조건문으로 나눠준다.

3. 초기값 정하기

- 길이가 `1`인 `i = 1` 에서는, `0`으로 계단 수가 시작할 수 없기 때문에 `j = 0`을 제외하고 전부 `1`로 초기화해주면 된다.

- 처음엔 명시적으로 길이가 `2`인 `i = 2`도 아래처럼 초기화 해줬는데,\
생각해보면 길이가 `2` 부터는 위의 점화식대로 하면 되기 때문에, 바로 시작하면 됨 \
(`dp[2][1]`에서 `01`의 경우는 어쩌피, `dp[1][0]`이 `0`이기 때문에 카운트되지 않아서 초기값을 안해줘도 됨)

```
// 2. 길이가 2일 때 0, 1, 9 는 앞에 1개만 올 수 있기 때문에 1개씩만 존재하고(10, 21, 89), 나머지는 앞에 2개가 올 수 있기 때문에 2개씩 존재
for (int i = 0; i <= 9; i++)
{
    dp[2][i] = 2;
    if (i == 0 || i == 1 || i == 9)
        dp[2][i]--;
}
```

## 전체 코드

```
// 초기값 설정
// 1. 길이가 1일 때는, 1 ~ 9 까지 1개씩만 존재 (0으로 시작할 수 없기 때문)
for (int i = 1; i <= 9; i++)
    dp[1][i] = 1;

// 2. 길이가 2일 때 0, 1, 9 는 앞에 1개만 올 수 있기 때문에 1개씩만 존재하고(10, 21, 89), 나머지는 앞에 2개가 올 수 있기 때문에 2개씩 존재
// for (int i = 0; i <= 9; i++)
// {
//     dp[2][i] = 2;
//     if (i == 0 || i == 1 || i == 9)
//         dp[2][i]--;
// }

// 점화식 찾기 : 0도 가능하다는 것을 기억해야함
// j = 0인 경우에는 j - 1이 존재할 수 없기 때문에 j + 1만 더해주고, 이외에는 j - 1과 j + 1을 다 더해주면 됨
for (int i = 2; i <= n; i++)
{
    for (int j = 0; j <= 9; j++)
    {
        if (j == 0)
            dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % 1000000000;
        else if (j == 9)
            dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % 1000000000;
        else
            dp[i][j] = (dp[i][j] + dp[i - 1][j - 1] + dp[i - 1][j + 1]) % 1000000000;
    }
}

// 길이가 n인 자리에 들어갈 수 있는 정수에 대한 계단수의 개수를 전부 더해주면 결과 값이 나옴
int res = 0;
for (int i = 0; i <= 9; i++)
    res = (res + dp[n][i]) % 1000000000;

cout << res;
```
