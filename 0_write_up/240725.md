# Dynamic Programming (다이나믹 프로그래밍, 동적 계획법)

- 여러 개의 하위 문제를 먼저 푼 후 그 결과를 쌓아 올려 주어진 문제를 해결하는 알고리즘

- 피보나치 수열을 예로 들면, `recursion`으로 풀면 중복된 연산이 계속 발생하여 `O(1.618 * N)`의 시간이 걸리지만, `DP`를 사용하면 `O(N)`의 시간으로 해결할 수 있음\
: **이전의 과정을 테이블에 저장해두기 때문**

## DP를 푸는 과정

1. 테이블 정의하기

2. **점화식 찾기**

3. 초기값 정하기

# `1463` : 1로 만들기

- DP가 아니라 입력 받은 수를 3이나 2로 나눠보거나 1을 빼면서 최종적으로 1으로 만들기 위해,\ 
하나씩 넣어보며 해보는 것은 어떤 연산을 먼저 해야할지 순서를 정할 수 없고, 시간도 오래 걸리므로 이 문제를 해결할 수 없음(시간 제한 : 0.15초)

- DP를 사용하여 아래와 같이 문제를 풀이해야함

## `1463-1.cpp` 풀이 방법 (정석)

1. 테이블 정의하기

- `dp[i]` : `i`를 `1`로 만드는데 필요한 연산의 최솟값

- `int *dp = new int[n + 1]; // index를 1부터 사용하기 위해`

2. 점화식 찾기

- `dp[i] = min(dp[i/3] + 1, dp[i/2] + 1, dp[i - 1] + 1)` : `i`가 3이나 2로 나누어 떨어지지 않는다면 그 수로 나누는 후보는 삭제해도 됨

```
for (int i = 2; i <= n; i++)
{
    dp[i] = dp[i - 1] + 1; // 초기값이 0이므로, 먼저 1을 뺀 연산부터 업데이트해줘야함

    if (i % 2 == 0) // 2으로 나누어 떨어지면, 1을 뺀 연산과 최솟값 비교 후 업데이트
        dp[i] = min(dp[i], dp[i / 2] + 1);

    if (i % 3 == 0) // 3으로 나누어 떨어지면, 위의 결과 값과 최솟값 비교 후 업데이트
        dp[i] = min(dp[i], dp[i / 3] + 1);
}
```

3. 초기값 정하기

- 입력 받은 정수를 `1`로 만들어야 하고, `1`의 경우는 연산을 추가적으로 사용할 필요가 없기 때문에 `0`으로 정의해주면 됨

- `dp[1] = 0; // 초기값 설정`

## `1463-2.cpp` 풀이 방법

- 테이블 정의하기, 점화식 찾기, 초기값 정하기의 단계는 동일하지만, 점화식을 통해 `d[i]`를 찾을 때 뒤에서 앞으로 찾는 것이 아닌, 앞에서 뒤로 순차적으로 채워나가도록 구현하였음

- 이렇게 되면, `d[i + 1]`이 `0`일 수도 있기 때문에 이 경우는 바로 업데이트 해주고 각 연산과의 비교를 통해 값을 업데이트 해줌

- 주의 사항은 `n+1` 만큼 테이블을 선언하였기 때문에, 반복문을 돌 때 `i * 2`와 `i * 3`이 `n`을 넘어가지 않는지 체크해줘야 `segfault`가 발생하지 않고,\
`n-1` 까지만 순회하면 `n`까지 전부 채워짐

```
for (int i = 1; i <= n - 1; i++)
{
    if (dp[i + 1] == 0 || dp[i + 1] > dp[i] + 1)
        dp[i + 1] = dp[i] + 1;

    if (i * 2 <= n && (dp[i * 2] == 0 || dp[i * 2] > dp[i] + 1))
        dp[i * 2] = dp[i] + 1;

    if (i * 3 <= n && (dp[i * 3] == 0 || dp[i * 3] > dp[i] + 1))
        dp[i * 3] = dp[i] + 1;
}
```