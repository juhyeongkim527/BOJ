# `9251` : LCS(최장 공통 부분 수열)

**테이블과 점화식을 찾기 힘들 때, 일단 모든 경우의 수에 대한 매트릭스를 한번 그려보면서 규칙을 파악하자.**

## 풀이 방법

두 문자열이 입력으로 들어오고, `9251-wrong.cpp` 처럼 한쪽 문자열을 기준으로만 탐색하면 `VREGDFELK, VLSKD` 의 경우 `VLK`가 아닌 `VD`에서 끝나기 때문에 판단 불가능

따라서, 두 문자열에서 모든 LCS를 판단하기 위해 2차원 배열로 테이블을 정의해서, **각 문자열의 `n`번째 문자에서 LCS의 길이를 저장하도록 해야함**

1. 테이블 정의하기

- `dp[i][j]` : `s1[i - 1]`과 `s2[j - 1]` 까지의 문자열에서 LCS의 길이

점화식에서 `dp[i - 1][j - 1]`을 탐색하기 때문에 `dp[0][j]`, `dp[i][0]` 를 한번에 초기화 하기 위해 전역 변수로 `1-index`를 사용하였고,

`s1`, `s2`는 `0-index`이므로 `[i]` `[j]`가 아닌 `[i-1]`, `[j-1]`으로 index를 접근해야함

2. 점화식 찾기

- `s1[i - 1] == s2[j - 1]` 인 경우, `dp[i][j] = dp[i - 1][j - 1] + 1;`
    - 현재 `i, j`에서 두 문자열의 끝이 같은 경우, `s1, s2`에서 `i, j`의 문자열이 추가되지 않은 `dp[i - 1][j - 1]`에서 LCS의 길이가 1 늘어나야 함
    - 예를 들어, `PCA` `ACA`의 경우 `PC`, `AC` 의 LCS 길이에서 1이 늘어나야 함

- `s1[i - 1] != s2[j - 1]` 인 경우, `dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);`
    - 현재 `i, j`에서 두 문자열의 끝이 다른 경우, 테이블의 위쪽인 `[i - 1][j]`와 왼쪽인 `[i][j - 1]`중 더 큰 LCS를 가져야함
    - 왼쪽인 `[i][j - 1]`을 선택하는 경우는 직관적이라 제외하고, 위쪽인 `[i - 1][j]`도 고려해줘야 하는 이유는 `j`가 추가되며, `s1[i - 1] == s2[j]`가 될 수 있기 때문
    - 예를 들어, `s1 : CAP`, `s2 : ACA`인 경우 `s2`에서 `A`가 추가되며, `P`와는 다르지만, `CA`가 `LCS`가 되는 경우가 생김

3. 초기값 정하기

`1-index`를 사용하였기 때문에 미리 전역 변수로 `dp[0][j]`와 `dp[i][0]`은 초기화 되어있음

## 전체 코드

```
for (int i = 1; i <= s1.length(); i++)
{
    for (int j = 1; j <= s2.length(); j++)
    {
        if (s1[i - 1] == s2[j - 1])          // 두 문자가 같은 경우
            dp[i][j] = dp[i - 1][j - 1] + 1; // 왼쪽 대각선에서 +1 을 해줌
        else
            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); // 왼쪽과 위쪽에서 더 큰 값을 골라줌
    }
}

cout << dp[s1.length()][s2.length()];
```