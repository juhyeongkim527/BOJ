# `11726` : 2xn 타일링

## 풀이 방법

1. 테이블 정의하기

- `dp[i]` : 가로가 `i` 인 직사각형을 채우는 방법의 수

2. 점화식 찾기

- `2 x n` 직사각형을 `2n`개의 `1 x 1` 정사각형으로 나누었을 때, 가장 왼쪽 위의 정사각형을
    
    - `2 x 1` 타일로 채우면, 가로가 1칸 채워지고 `2 x (n-1)` 직사각형이 남기 때문에, 남은 타일의 경우의 수는 `dp[i - 1]` 이다.
    
    - `1 x 2` 타일로 채우면, 가로가 2칸 채워지고 `2 x (n-2)` 직사각형이 남기 때문에, 남은 타일의 경우의 수는 `dp[i - 2]` 이다.

- 따라서, 점화식은 `dp[i] = dp[i - 1] + dp[i - 2]`이다.

- 주의할 점은, **어쩌피 최종적으로 출력할 값이 `dp[n]`을 `10007`으로 나눈 값이므로, `int overflow`를 방지하기 위해 점화식에 `10007`의 나머지를 대입해줘야 한다.**\
어쩌피 전체를 마지막에 나눌 거면, 더해지는 과정에서 나눠도 상관없기 때문이다.
: `dp[i] = (dp[i - 1] + dp[i - 2]) % 10007;` (`long long` 으로도 `overflow`가 나므로 매번 나눠줘야함)

3. 초기값 정하기

- 점화식에서 `i - 2` 가 존재하기 때문에, `i = 2` 까지는 구해줘야 `i = 0`에 접근하지 않는다.

```
dp[1] = 1;
dp[2] = 2;
```

## 전체 코드

```
// 초기값 정하기
dp[1] = 1;
dp[2] = 2;

for (int i = 3; i <= n; i++)
    dp[i] = (dp[i - 1] + dp[i - 2]) % 10007; // 점화식 찾기

cout << dp[n];
```

## `Top-Down` 방식 재귀 풀이

기존에 피보나치 재귀처럼 계산 값을 저장하지 않고 중복 계산 하는 것 대신, 계산값을 저장하여 계산 값이 있으면 바로 리턴하는 재귀 함수를 작성하여서도 해결할 수 있음 : 시간초과 해결 가능

```
long dp[1001]; // 테이블 정의하기 : dp[i] 는 2 x i 직사각형을 타일로 채우는 경우의 수 (n <= 1000, 1-index)

int topdown(int n)
{
    if (n == 1)
        return 1;
    if (n == 2)
        return 2;
    if (dp[n] != 0)
        return dp[n];

    return dp[n] = (topdown(n - 1) + topdown(n - 2)) % 10007;
}
```

# `11727` : 2xn 타일링 2

## 풀이 방법

`11726` 번에서 `2 x 2` 타일이 추가된 상황의 문제이므로, 똑같은 상황을 가정하여 왼쪽 위부터 `1 x 2`, `2 x 1` 타일을 채우는 경우에서 `2 x 2` 타일을 채우는 경우를 추가하면 됨

`2 x 2` 타일을 왼쪽 위에 두는 경우는 `dp[i] = dp[i - 2]`가 되어서, `1 x 2`를 채우는 경우와 같지만, 둘은 다른 경우이기 때문에 중복으로 치지 않고 각각 더해주면 됨

1. 테이블 정의하기

- `dp[i]` : 가로가 `i` 인 직사각형을 채우는 방법의 수

2. 점화식 찾기

- `dp[i] = dp[i - 1] + 2 * dp[i - 2]`이다. (문제에서는 10007로 나눈 값을 물어보기 때문에, `dp[i] = (dp[i - 1] + 2 * dp[i - 2]) % 10007;`)

3. 초기값 정하기

- 점화식에서 `i - 2` 가 존재하기 때문에, `i = 2` 까지는 구해줘야 `i = 0`에 접근하지 않는다. (이번엔 `2 x 2`를 채울 때, 3개의 경우의 수가 존재함)

```
dp[1] = 1;
dp[2] = 3;
```

## 전체 코드

```
dp[1] = 1;
dp[2] = 3;

for (int i = 3; i <= n; i++)
    dp[i] = (dp[i - 1] + 2 * dp[i - 2]) % 10007;

cout << dp[n];
```

## `Top-Down` 방식 재귀 풀이

```
int topdown(int n)
{
    if (n == 1)
        return 1;
    if (n == 2)
        return 3;
    if (dp[n] != 0)
        return dp[n];

    return dp[n] = (topdown(n - 1) + 2 * topdown(n - 2)) % 10007;
}
```

# `11660` : 구간 합 구하기 5

`n x n` 표에서, `(1, 1)`부터 입력 받은 `(x, y)` 까지의 직사각형의 누적합을 구해야, 시작점이 `(x1, y1)`이고 끝점이 `(x2, y2)`인 직사각형의 누적합을 구할 수 있다.

따라서, 아래의 그림과 같이 `Summed area Table`을 이용하여 구할 수 있다. 

<img width="663" alt="image" src="https://github.com/user-attachments/assets/8d3e7e5a-72e1-4860-8071-b9da9bf6f9c0">

## 풀이 방법

1. 테이블 정의하기 

- `dp[i][j]` : 시작점부터 `(i, j)` 를 끝점(right-bottom)으로 하는 직사각형을 만들었을 때의 누적합

2. 점화식 찾기

- 그림을 참고하여, `dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + arr[i][j]`로 구할 수 있음

3. 초기값 정하기

- `1-index`를 사용하기 때문에, row나 col이 `0`인 값은 이미 0으로 초기화 되있어서 따로 초기화해줄 필요가 없음

## 전체 코드

```
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= n; j++)
        cin >> arr[i][j];

// 초기값은 row, col이 0인 경우 어쩌피 0으로 초기화되어있어서 해줄 필요 없음
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= n; j++)
        // 점화식 찾기 : dp[i - 1][j] + dp[i][j - 1] 에서 중복되는 dp[i - 1][j - 1]을 빼주고 arr[i][j]를 더해주면 됨
        dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + arr[i][j];

int x1, y1, x2, y2; // 헤더 파일에 y1 이라는 변수나 함수 이름이 있어서 전역 변수에는 선언 불가능 (count, max처럼)
while (m--)
{
    cin >> x1 >> y1 >> x2 >> y2;
    cout << dp[x2][y2] - dp[x2][y1 - 1] - dp[x1 - 1][y2] + dp[x1 - 1][y1 - 1] << '\n';
}
```
