# `1300` : K번째 수

지금까지 이진 탐색 문제를 풀면서, 마지막에 `mid`를 그냥 출력했는데 이게 가능한 경우도 있지만 이번 문제에서는 마지막에 `mid`가 `1` 차이나게 설정되어 버리기 때문에, 그냥 이진 탐색 문제에서는
`mid`가 가능한 조건일 때, 전부 `res`와 같은 변수에 `mid` 값을 업데이트 해준 후 마지막에 `res`를 출력하는 것으로 하자.

**그리고 이진 탐색에서는 찾고자 하는 값의 후보를  항상 `mid`를 업데이트 하며 찾는다는 것을 기억하자.**

## 풀이 방법

이번 문제도 아이디어를 떠올리기 힘들었다. 배열 `B`의 `k` 번째 값을 찾는 것인데, `N x N` 크기의 2차원 배열인 `A`를 오름차순으로 정렬했을 때, 배열의 원소가 중복되는 동시에 규칙성을 찾기 힘들기 때문에 간단히 풀기 힘들었다.

**`mid`를 항상 찾고자 하는 값의 후보로 두면 된다는 아이디어를 통해**, 찾고자 하는 배열 B의 `k`번째 수를 `mid`라고 두면 `B[k] = mid`가 될 것이다.

배열의 `k`번째 값이 `mid`라는 것은, `mid`보다 작거나 같은 값이 `k`개 존재한다는 것이다. 따라서, `k`와 개수를 비교할 `cnt` 변수가 필요하다.

여기서 주의할 점은 배열의 원소가 중복되기 때문에, `mid`를 통해 찾은 `cnt`의 값이 `k`보다 커지는 경우도 `mid`의 후보가 될 수 있다는 것이다.

### 이진 탐색 과정

1. 가장 작은 원소의 값은 `1`이고, 가장 큰 원소의 값은 `n * n`이므로, `left`와 `right`를 각각 최솟값과 최댓값으로 설정해준다.

2. 이제, `(1, 1)` 부터 `(n, n)` 까지 `mid` 보다 작거나 같은 값을 찾아야 하는데, 여기서 이중 for문을 사용하면 `n`의 범위가 `10^5` 까지 가능하기 때문에 `1300-TLE.cpp`에서 처럼 시간 초과가 발생한다.

3. 따라서, `1 ~ n` 까지 `row`만 탐색하여 `O(n)`의 시간으로 `mid`보다 작거나 같은 원소 값을 찾는 방법을 떠올려야 한다. 아래 성질을 통해 아이디어를 찾을 수 있다.
    
    1. 각 `row`는 `col`이 증가할 때마다(오른쪽으로 갈수록) `row`의 번호만큼 증가한다.
    
    2. 따라서, `mid`를 각 `row`로 나눠준 값인 통해 `mid / i`를 통해 `mid` 보다 작거나 같은 원소의 개수를 구할 수 있다. 
        - ex) `row = 3`,  `mid = 7`인 경우, 가능한 원소는 `3, 6`인데 `7 / 3 = 2` 으로 계산 가능
 
    3. 여기서 `mid`의 범위는 `n * n`까지 후보가 가능하기 때문에, `n`보다 큰 경우 `mid / i` 가 `row`에서의 `col` 개수인 `n`보다 커질 수 있기 때문에 `min(mid / i, n)`을 해줘야 한다.

    4. 반복문을 돌면서 `cnt += min(mid / i, n)`으로 개수를 계속 세준다. (`n < 10^5`인 정수이므로 `long`으로 선언해줘야 하는거 주의하자.)

4. `mid`를 업데이트 해야할 조건을 파악한다

    - `cnt > k`인 경우, `mid`보다 작거나 같은 원소의 개수가 찾고자 하는 `k`보다 많은 것을 의미한다. 배열에는 원소가 중복해서 존재하기 때문에 `cnt > k`여도 `mid`가 후보가 될 수 있기 때문에 `res = mid`를 통해 해당 `mid`를 대입해준 후, `mid`를 줄였을 때도 `cnt >= k`인지 확인해봐야 하기 때문에 `right = mid - 1`으로 `mid`의 후보를 줄여본다.

    - `cnt < k`인 경우, `mid`보다 작거나 같은 원소의 개수가 찾고자 하는 `k`보다 적은 것을 의미한다. 따라서 이 경우에는 `B[k] = mid`를 만족하지 않기 때문에 `k`를 증가시켜서 `k`번째 수가 될 수 있도록 `left = mid + 1`을 해준다.

    - `cnt == k`인 경우, `mid`보다 작거나 같은 원소의 개수가 찾고자 하는 `k`와 같은 것을 의미한다. 그런데 여기서 `mid = 7`인데 실제로 `B[k] = 6`인 경우가 존재할 수 있다.
    왜냐하면, `B`의 원소는 `1`씩 증가하는 것이 아니기 때문이다. 따라서, `mid`를 줄여서 `cnt == k`가 될 수 있는 후보가 더 존재한다면 그 `mid`가 `res`가 될 수 있기 때문에, 일단 `res = mid`로 저장해준 후 `right = mid - 1`로 한번 더 검사해줘야 한다.

## 전체 코드

```
long left = 1;      // B[k]가 될 수 있는 최솟값
long right = n * n; // B[k]가 될 수 있는 최댓값
long mid;           // B[k] 후보

int res; // B[k] 의 최종값 저장
while (left <= right)
{
    long cnt = 0; // B[K] 보다 작은 값의 개수
    mid = (left + right) / 2;

    // mid = (left + right) / 2;
    for (int i = 1; i <= n; i++)
        // row에 대해 1 ~ n 까지 검사
        // (mid / i)는 i번째 row에서 mid보다 작은 col값의 개수임
        // 왜냐하면 i번째 row는 col이 증가할 수록, 이전 col에서 i씩 증가하는데 (mid / i)를 하면 딱 mid보다 작은 i번째 row에서의 col 개수가 나옴
        // 그런데, col 개수는 n개이므로, (mid / i) 가 n보다 커질 수 있기 때문에, 해당 경우에 min()을 통해 검사해서 n을 넣어줘야함
        cnt += min(mid / i, n);

    if (cnt > k)
    {
        // B[k] = mid 일 때, mid보다 작은 값의 개수가 k보다 많은 경우, mid를 줄여서 후보를 줄여야함
        right = mid - 1;
        // mid의 값이 중복되는 경우 cnt를 넘을 수 있기 때문에 여기서도 res를 업데이트해줘야함
        res = mid;
    }

    else if (cnt < k) // B[k] = mid 일 때, mid보다 작은 값의 개수가 k보다 적은 경우, mid를 늘여서 후보를 늘여야함
        left = mid + 1;

    else if (cnt == k)
    {
        // B[k] = mid 일 때, mid보다 작은 값의 개수가 k와 같은 경우,
        // B[k] = mid가 더 작아질 때도 k를 만족하는 경우가 생기면 그때가 정답이므로 mid를 줄여서 다시 검사해봐야함 (mid가 꼭 B[k]라는 보장이 없기 때문)
        // 예를 들어 mid가 5인데, 실제 B[k] = 4 인 경우, mid를 줄여서 4일 때로 판단해야함
        right = mid - 1;
        res = mid;
    }
}

cout << res;
```

# `12015` : 가장 긴 증가하는 부분 수열 2

DP로도 답을 구할 수는 있지만, 수열의 크기가 `1,000,000` 까지 가능하기 때문에 이중 for문을 쓰면 시간 초과가 나버린다.

따라서, 시간을 더 줄일 수 있는 알고리즘을 생각해봐야 하는데 `O(nlogn)`의 시간 복잡도로 해결할 수 있는 이진 탐색 방법을 사용할 수 있다. (for문 `O(n)` * 이진 탐색 `(Ologn)`)

문제 힌트에 `O(nlogn)`의 시간이 필요하다는 것을 통해 반복문 `O(n)`과 이진 탐색 `O(logn)`을 결합하여 문제를 풀 수 있을 것이라는 생각을 할 수 있기 때문이다.

## 풀이 방법

`[10 20 30 5 40]` 이라는 입력이 들어온다고 생각해보자. 이 때는 명확하게 가장 앞의 원소부터 시작하는 `[10 20 30 40]`이 결과가 되는데, `[10 20 30 5 10 15 20]` 인 경우 4번째 원소인 `5` 부터 시작하는 `[5 10 15 20]`이 정답이 된다.

아이디어를 떠올리기 매우 힘들지만 생각해보면, 첫번째 인덱스부터 시작해서 가장 긴 부분 수열의 길이를 찾기 위해 `cmp` 라는 배열을 선언하여 아래의 규칙에 따라 값을 계속 추가해보며 풀이할 수 있다.

1. `arr` 배열을 차례대로 탐색하며, `cmp`의 마지막 원소보다 `arr[i]` 의 원소가 크다면 맨 끝에 `arr[i]`를 `insert` 해준다. (이렇게 하면 알아서 오름차순으로 정렬된다.)

2. 만약 `cmp`의 마지막 원소보다 `arr[i]`의 원소가 더 작거나 같다면, `cmp`의 원소 중 `arr[i]`와 같거나, 차이가 가장 적으면서 큰 원소를 찾아서 해당 자리를 `arr[i]`로 대체한다.
    
    - 여기서, `cmp`의 자리를 찾을 때 모든 `cmp` 원소를 탐색하는 것이 아닌 이진 탐색을 사용하면, `O(n)`이 아닌 `O(logn)`으로 시간 복잡도를 줄일 수 있다.

    - `left, right, mid`를 `cmp`의 `index`로 설정하면 된다.

    - 해당 조건에서는 `cmp`의 원소를 대체하는 것이지 `insert`를 하는 것이 아니기 때문에 `cmp`의 길이를 증가시키면 안되므로, `cmp`의 마지막 인덱스를 가리키는 원소를 `1.` 번에서만 업데이트 해야한다.

3. 해당 규칙을 통해 `arr`을 전부 탐색한 후 마지막에 `cmp` 원소의 길이를 출력하면 가장 긴 증가하는 부분 수열의 길이를 찾을 수 있다.

위 규칙으로 `arr`을 전부 탐색한 후 `cmp` 원소의 길이를 출력하면 되는 이유는, 이번 문제에서 가장 긴 증가하는 부분 수열 자체를 구하는 것이 아닌, `길이`만 구하면 되기 때문이다.

예를 들어, `[10 20 30 5 10 15 20]`의 경우를 보면

`[10]` > `[10 20]` > `[10 20 30]` 으로 가다가, `5`를 만나면 `[5 20 30]`이 된다. 

여기서, `5`를 만나서 `cmp`의 수열이 바뀌었음에도 불구하고 이전에 구했던 가장 긴 부분 수열의 길이는 유지되기 때문에 뒤에 `40`이 오면 바로 `[5 20 30 40]`이 되서 가장 긴 부분 수열이 유지되고,

해당 예제처럼 `10`이 들어와도 `[5 10 30]`으로 부분 수열을 계속 업데이트해나가면서 마지막엔 `[5 10 15 20]`을 만들 수 있다.

하지만, 이렇게 구하면 `[10 20 30 5]`인 경우 마지막에 `cmp`가 `[5 10 20]`이 되기 때문에 `길이`는 제대로 구할 수 있지만 수열 자체는 구할 수 없다.

## 전체 코드

```
cmp[0] = arr[0]; // 초기값 설정
int end_idx = 0; // 마지막 원소를 가리키는 index : 가장 긴 증가하는 부분 수열을 유지하기 위해서 필요 (가장 긴 증가하는 부분 수열의 길이 - 1)

for (int i = 1; i < n; i++) // arr의 모든 원소를 순회
{
    if (cmp[end_idx] < arr[i]) // arr[i]가 현재 cmp의 마지막 원소보다 큰 경우 idx 뒤에 insert (이미 원소가 있었다면 대체)
        cmp[++end_idx] = arr[i];

    else if (cmp[end_idx] == arr[i]) // arr[i]가 cmp의 마지막 원소와 같은 경우 넘어가면 됨
        continue;

    else // arr[i]가 cmp의 마지막 원소보다 작은 경우
    {
        int left = 0;        // cmp의 시작 index
        int right = end_idx; // cmp의 끝 index
        int mid;             // cmp에서 arr[i]와 차이가 가장 작으면서 값이 큰 index (또는 값이 같은 index)
        int res;             // mid를 저장할 변수

        while (left <= right)
        {
            mid = (left + right) / 2;

            if (arr[i] < cmp[mid]) // 넣고자 하는 arr[i]가 cmp[mid] 보다 작으면 일단 해당 mid가 후보가 되므로 res에 저장 후, mid를 더 줄여봄
            {
                res = mid;
                right = mid - 1;
            }

            if (arr[i] == cmp[mid]) // 넣고자 하는 arr[i]가 cmp[mid]와 같은 경우, 바로 여기에 넣으면 되기 때문에 res에 넣은 후 break로 이진 탐색을 탈출
            {
                res = mid;
                break;
            }

            if (arr[i] > cmp[mid]) // 넣고자 하는 arr[i]가 cmp[mid]보다 큰 경우, 해당 위치에는 넣을 수 없기 때문에 mid를 키워서 cmp[mid]의 후보를 키워야함
            {
                left = mid + 1;
            }
        }

        cmp[res] = arr[i]; // 찾은 index에 arr[i]를 대입 : insert가 아닌 값 대체
    }
}

cout << end_idx + 1; // 마지막 (index + 1)이 길이가 됨
```

## 이진 탐색 정리

1. `mid`를 찾고자 하는 값의 후보로 둔다.
    
    - `mid = (left + right) / 2;`로 계산하기 때문에 `int overflow`를 유의하자.

2. `left`, `right`를 찾고자 하는 값의 최솟값과 최댓값으로 둔다.

3. `mid`가 찾고자 하는 값을 만족하는 경우 `res`에 `mid`를 저장해주고, 더 적절한 후보가 있는 경우 `left`나 `right`를 업데이트 해준다.\
    
    - 여기서 `res`를 업데이트 해주지 않고 마지막에 `left, right, mid` 중 출력하면 논리를 생각하기 힘드고 `mid`를 업데이트 해주는 위치도 신경써줘야 하기 때문에, `mid`를 업데이트 해주는 위치도 자유롭고 `res`만 출력하면 되도록 `res = mid`로 업데이트 하는 코드를 작성하자.