# 1620 

1. map은 단방향 매핑(key로만 탐색)만 가능하므로 `<string, int>`에서 key (string) <-> value (int) 양방향 탐색을 하려면 `<int, string>` map을 하나더 생성해줘야함
2. set은 요소를 추가할 때마다 오름차순으로 정렬되기 때문에 입력 순서와 index가 일치하지 않게 됨 (map도 마찬가지지만 value나 key를 int인 index로 설정은 가능)
3. `vector<string> vec(5)` 처럼 미리 크기를 5로 지정해버리면, `push_back` 으로 요소를 추가할 때 index 0부터가 아닌 index 5부터 들어가므로 주의해야함
4. `vector<string> vec(5, "some_string")` 처럼 초기화 가능
5. `lower_bound(vec.begin(), vec.end(), target)`은 iterator를 반환하는데, 해당 iterator가 가리키는 index를 찾기 위해 `distance(vec.begin(), it)`을 써도 되지만 바로 `lower_bound(vec.begin(), vec.end(), target) - vec.begin()`을 써주면 index를 찾을 수 있음.
6. `lower_bound`와 같이 binary search를 사용하기 위해서는 vector가 항상 **sort** 되있어야 한다는 것을 기억하기 : 이러면 기존 index가 유지되지 않는다는 것도 기억
7. 그리고 iterator를 return하는 함수들은 항상 target을 못 찾을시에 `vec.end()`를 return하고 이 iterator는 vec의 마지막 요소를 가리키는게 아닌 vector의 마지막 요소 다음을 가리킨다는 것을 기억하기. `vec.begin()`은 벡터의 첫번째 요소를 가리키는거 맞고 그래서 `erase` 같은 함수의 삭제 범위는 **[,)** 임

# 10816

1. map에서 `map.insert(key, value)`는 항상 `pair<iterator, bool>`을 return하는데, map은 `key`의 중복을 허용하지 않으므로 만약 `key`가 이미 map에 존재하는 경우 새로운`value`로 업데이트 하지 않고 `bool == false`를 return하고, `key`가 존재하지 않는 경우 새로운 `value`로 업데이트 한 후 `bool == true`를 리턴함 : 이를 통해 현재 map에 `key`가 존재하는지 알 수 있음
2. map에서 `map.insert(key, value)` 가 아닌 `map[key] = value`를 하면 무조건 `key`가 존재하더라도 새로운 `value`로 update됨
3. 사실은 c++에서 `map<int, int>`를 사용할 때, `key`에 해당하는 `pair`를 하나 만들면 알아서 `value`가 초기에 0으로 초기화되서, 이번 문제에서는 `m[tmp]++`만 썼어도 되긴 함

4. map을 사용하지 않고, vector를 사용한 **binary search**로 해당 `key`가 존재하는지, 그리고 몇개 존재하는지 확인하려면 `sort` 후 `upper_bound - lower_bound`를 하는게 제일 간단함. 왜냐하면, `upper_bound`는 target을 초과하는 iterator를 return하는데 존재하지 않는 경우 `upper_bound`와 `lower_bound`가 같은 곳을 가리키기 때문에 0을 출력할 수 있기 때문

5. ***10815*** 번에서는 중복이 없었기 때문에 존재하는지 확인하는 것에도 `upper_bound - lower_bound`를 사용하였지만 중복이 있을 경우, 존재하는지만 출력하려면 `lower_bound`만 사용해서 `vec.end()`와 같은지 확인하거나 `binary_search`를 바로 쓰면 됨