# 1037

1. N의 진짜 약수가 주어졌을 때, N을 구하기 위해서는 약수의 `최솟값 * 최댓값`을 구하면 됨

# 25192

- "ENTER"로 들어온 새로운 유저들에게 전부 인사를 해야 된다고 생각했는데, 가장 최근에 들어온 "ENTER" 유저에게만 인사하면 되어서 `25192-map.cpp`이나 `25192-set.cpp`처럼 해야함

- **`vector`는 `key`를 탐색할 때 `sort` 후 `binary_search`를 해줘야 하므로 바로 이진 탐색이나 해시를 사용할 수 있는 `map`이나 `set` 사용**

- EX 1) "ENTER" -> "ENTER" -> "user1"

- 위의 예에 대해서 인사를 1번만 하면 되지만 인사를 2번 해야 된다고 생각해서 `25192-1.cpp`처럼 구현

## `25192-map.cpp`

1. `map<string, bool> users;` 에 채팅을 친 유저가 인사를 했는지 저장

2. `message == "ENTER"` 인 경우 모든 users가 새로 인사를 해야 하므로, `map`의 모든 `users`를 `false`로 초기화

### `map<string, bool> users;` 을 사용한 경우 : `key`의 정렬이 필요할 때 사용

- **이진 트리를 사용하는** `map`의 경우 `users`를 전부 `false`로 초기화 할 때, 처음에 아래의 코드를 사용했었음\
(참고로 `auto &it`을 하지 않으면 복사본을 가져오므로 `false`로 초기화가 안됨)

```
for (auto &it : users)
{
    it.second = false;
}
```

- 위처럼 하면 실제로 모든 `data`에 접근하는데, `O(n)`의 시간이 들어서 TLE가 발생하지 않아야 하지만, TLE가 발생했음.\
그래서 다른 풀이를 참고해서 `users.clear();` 으로 고쳤더니 TLE가 발생하지 않음

- 왜냐하면 둘다 알고리즘 자체는 `O(n)`이지만, 위의 방식대로 하면 "ENTER" 이전에 들어온 값은 전부 필요가 없음에도,\
이후에도 계속 누적되어 `false`로 바꿔줘야해서 아래의 `unordered_map`에서 버킷 크기로 `n`이 정해지는 것과 같은 비효율이 발생함

- `clear()`를 해주면 그냥 "ENTER" 이전의 값은 이후에 다시 `O(n)`에 포함되지 않으므로 훨씬 효율적임

### `unordered_map<string, bool> users;` 을 사용한 경우 : `key`의 정렬이 필요하지 않을 때 사용

- **해시를 사용하는** `unordered_map`을 사용하면 오히려 `key` 입력시 정렬을 사용하지 않아도 되니까 더 빠르지 않을까 라고 생각했음

- 그리고 아래에서 `key`를 `search`할 때에도 해시 충돌이 발생하는 최악인 `O(n)`을 제외하면 평균 `O(1)`의 시간복잡도가 발생하므로 더 빠를 것이라고 예상\
(`map`은 `O(logn)`)

- 하지만, `unordered_map`을 사용하면 `users.clear();`를 할 때 버그가 있어서 `O(n)`이 아닌 예전에 `clear`하기 전의 **버킷 크기까지 누적되어서 TLE가 발생**

- 따라서, `users.erase(users.begin(), users.end());`를 하면 버그가 없어서 TLE가 발생하지 않음 : 전체 속도도 훨씬 빠름

## `25192-set.cpp`

- 사실 생각해보면, "ENTER" 이후 유저가 처음 채팅을 쳤는지만 확인해보면 되니까, `map` 대신 `set`을 사용해서 `set`에 `insert`된적이 있는지만 확인하면 돰

- 마찬가지로 정렬이 필요없으니 `unordered_set`을 사용하였고, `clear()` 대신 `erase()`를 사용하였음

- `users.insert(message);`는 `pair<iterator, bool>`을 return 하는데, `key = message`가 이미 존재하는 경우 `pair.second`에 `false`가 return되므로,\
`pair.second == true`인 경우에만 처음 채팅을 친 것이므로 이때만 `greet_count++;`을 해주면 됨

## `25192-1.cpp`

- "ENTER"로 들어왔던 모든 유저에게 인사를 해야한다고 생각해서, `enter_count`라는 변수를 설정하고,\
`map<string, int> users`로 인사한 횟수를 저장하여서 `enter_count`까지 loop를 돌며 인사를 하도록 구현

- 사실 문제에서는 가장 최근에 들어온 "ENTER"에게만 인사하면 되서 이렇게 하면 안되긴 함

# 26069

1. `unordered_set<string> dancing_users;`를 선언하여 춤추고 있는 user들을 저장

- 중복을 허용 안하고, 정렬할 필요가 없으며, 이진 탐색을 바로 하기 위해 `unordered_set`을 사용

2. `ChongChong`이 들어온 이후에 춤이 시작되므로, 그 전에는 set에 저장할 필요 X\
: 처음에 ChongChong을 만난 사람이 춤을 추면 과거에 만났던 사람들에게도 전염되는줄 알았는데, 이후에 만난 사람들에게만 전염되서 훨씬 문제가 쉬움

3. `ChongChong`이 들어오면 `ChongChong`과 같이 입력받은 `user`를 set에 `insert` 후 `chong_flag` 설정 : `find` 오버헤드를 줄이기 위해\
(사실 flag 설정 전에는 4.에서, 어쩌피 빈 set을 `find`해서 큰 overhead는 없기 때문에 꼭 flag를 설정할 필요는 없긴 함)

4. `flag`가 설정되면, 새로 들어오는 `user`마다 **dancing set에 있는지 확인해서 있으면 둘다 set에 넣음**