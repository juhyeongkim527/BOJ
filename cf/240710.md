# 17103

1. 입력을 받을 때 마다 일일히 소수를 판단하고, 소수의 합을 구하는 것은 매우 비효율적이고 시간이 많이 들 것임

2. 따라서, 미리 입력 값 범위의 에라토스테네스의 체를 만들어 두고 해당 배열에서 소수를 선택하여 합을 결정

- `17103.cpp` 에서는 미리 입력값인 1,000,001 크기를 가지는 배열을 **미리 계산하여 만들어 두고 입력 받을 때 마다 해당 배열을 사용**했고,\
`17103-1.cpp` 에서는 `number`를 입력 받을 때 마다 `number+1` 크기의 배열을 새로 계산하고 해제하였는데,\
`17103-1.cpp` 방법이 시간과 메모리 훨씬 더 많이 잡아먹음 : **범위가 심각하게 큰게 아니면 미리 한번에 큰 계산을 해두고 뒤에서 쓰는게 훨씬 효율적이다.**

3. `number`를 받을 때마다 에라토스테네스의 체에서 `number / 2` 까지 반복문을 순회하며 `number`에서 소수를 빼고, `number - 소수` 가 소수인지 판단하여 맞다면 `count++`

4. `number / 2`까지 하는 이유는 덧셈은 대칭이므로 `number / 2` 까지만 해도 좌우 결과가 같기 때문임

5. `number` 자체는 검증할 `number - 소수`가 소수가 아닐 때 다시 돌아와서 기존 `number`를 유지해야 하므로 비교를 위한 `cmp` 변수를 추가하였고, `cmp = number`의 위치가 반복문 어디에 위치해야 하는지가 중요함 : 항상 잘 체크하기

# 13909

### `13909-MLE.cpp`

1. 에라토스테네스의 체 알고리즘을 사용하여 반복문을 돌며 `count` 까지 현재 `i`의 배수가 되는 `bool *arr` 값을 bitwise NOT (`!`) 연산으로 바꿔줌

2. 창문 계산이 끝났다면, 1 부터 `count`까지 반복문을 돌며 `false : 열림` 인 경우 `open_cnt++`을 해주며 열린 창문의 수를 세어줌

3. 그런데 입력 범위가 2,100,000,000 이므로 `bool *arr = new bool[count + 1]`을 해주면 64 MB를 넘어서 MLE 발생

### `13909.cpp`

1. 열린 창문의 특성은 처음에 창문을 열기 때문에, 해당 N 번째의 창문을 **열고 닫는 횟수가 총 홀수번** 이어야 한다는 것이다. (만약 처음에 닫았다면 짝수번)\
그리고, N 번째 창문을 열고 닫는 횟수는 N 번째 창문의 약수가 열고 닫기 때문에 약수의 개수가 결정한다.

2. 창문을 홀수번 열고 닫기 위해서는 해당 창문의 약수 개수가 홀수여야 하는데, 이 수의 특징은 제곱수 라는 것이다.\
약수의 개수는 각 소인수에 1을 더한 후 곱하는건데, 홀수가 나오려면 홀수 * 홀수만 가능하므로 모든 소인수의 제곱이 짝수여야 가능하기 때문 : 이건 제곱수

3. 따라서, 해당 범위 내의 제곱수들을 구하면 된다. (범위 내의 모든 수를 소인수 분해를 하고 약수의 개수를 구하는 방식은 너무 비효율적이고 오래 걸림)

- 해당 범위에 제곱수의 개수를 구하기 위해서, 아래와 같이 `i = 1` 부터 시작해서, 해당 `i` 의 제곱수인 `i * i` 이 `count` 내에 존재할 때 까지 반복문을 돌면서 `i = 1, 2, 3...`의 개수를 세주면 된다.\
범위 내에 존재하는 제곱수는 전부 범위보다 작은 어떤 수의 제곱이기 때문이다.

```
int square_number_cnt = 0;
    for (int i = 1; i * i <= count; i++)
        square_number_cnt++;
```

- 또는 같은 논리로 **해당 범위의 루트를 씌운 결과에서 소수점을 날리면** 해당 범위의 제곱수를 구할 수 있다.\
왜냐하면 루트를 씌운 결과보다 작은 자연수들은 전부 해당 범위에 제곱수가 존재하기 때문이다.

```
int square_number_cnt = sqrt(count);
```

# 28278

1. `vector`로 stack 구현할거면 **무조건 `pop` 할 때, `vector.pop_back()` 해줘야 하는거 기억하기**.\
배열은 index로 접근하기 때문에 실제 value는 안 빼도 size만 바꿔줘도 되지만, vector는 사용하는 목적이 처음부터 배열과 달리 크기가 정해지지 않은 stack을 구현하는 것이고,\
따라서 index가 아닌 `push_back`으로 `insert`를 하기 때문에 꼭 `pop` 할 때 `vector.pop_back()`도 해줘야 하는거 기억하기.

2. 무조건 `pop`이나 `front` 전에 `is_empty`로 검사해줘야 하는거 기억하기. 아니면 segmentation fault남

# 9012

-  `cin` 은 개행문자를 무시하기 때문에 `char`를 한줄에 연속적으로 하나씩 받고 개행문자로 구분할 때, `\n`이나 `EOF`로는 개행문자를 구별 불가능 함\
따라서, 그냥 `string`에 다 받고 `string`을 반복문으로 순회하는게 나음 (`9012-err.cpp`)

- `front`와 `pop`을 구현할 때, 내부에 `is_empty`를 구현하지 않았기 때문에 아래 구현에서 `is_empty`를 먼저 해줘야 되는거 주의하기

### `9012-1.cpp`

1. '(' 입력시 무조건 `insert`

2. ')' 입력시 stack이 `비어있으면` 바로 NO 출력, `front`가 '(' 이면 `insert` 하지 않고 `pop`

3. 입력 받은 string 처리가 끝난 후 stack이 비어있고 위에서 NO를 출력하지 않았으면 YES 출력, stack이 비어있지 않고 위에서 NO를 출력하지 않았으면 NO 출력

4. ')'는 `insert`를 절대 하지 않기 때문에 `front`가 ')'인 경우는 없음, 그리고 비어있을 때 바로 NO를 출력하고 `break` 하므로,\
밖에서 NO를 출력했는지 검사하는 `bool no_flag`가 필요

```
for (char ch : tmp) // cin >> tmp는 '\n'을 건너뛰므로 char 자체로 개행문자를 확인할 수 없음 : string으로 입력받아야함
{
    if (ch == '(')
        s->insert(ch);

    else if (ch == ')')
    {
        // 뒤에서 front를 검사하므로 무조건 앞에서 is_empty를 먼저 검사해줘야함, 아니면 segmentation fault남
        if (s->is_empty())
        {
            cout << "NO\n";
            no_flag = true;
            break;
        }
        else if (s->front() == '(')
            s->pop();

        // else if (s->front() == ')') 인 상황은 있을 수 없음
        // ')'는 1. front가 '(' 일 때 pop을 하거나
        // 2. empty일 경우 NO만 출력하므로 insert 되서 stack에 연속으로 ')'가 있는 경우가 없기 때문
    }
}

if (!no_flag) // 앞에서 NO를 출력하지 않은 경우
{
    if (s->is_empty())
        cout << "YES\n";
    else
        cout << "NO\n";
}

delete s;
```

### `9012-2.cpp`

1. 위에서는 ')' 입력시 비어있으면 바로 NO를 출력하고, `no_flag`를 업데이트 했는데, 여기서는 그냥 비어있으면 `insert` 해줌

2. 어쩌피 여기서 `insert`된 ')'는 절대 `pop`되지 않으므로 뒤에서 `is_empty`에 들어가지 않아서 무조건 NO가 출력됨

```
for (char ch : tmp) // cin >> tmp는 '\n'을 건너뛰므로 char 자체로 개행문자를 확인할 수 없음 : string으로 입력받아야함
{
    if (ch == '(')
        s->insert(ch);

    else if (ch == ')')
    {
        // front를 검사하기 전에 무조건 is_empty 부터 검사해줘야함, 아니면 segmentation fault남
        // && 좌우 순서 거꾸로 쓰면 front부터 하므로 똑같이 segmentation fault남
        if (!s->is_empty() && s->front() == '(')
            s->pop();

        else
            s->insert(ch);

        // if (s->is_empty())
        //     s->insert(ch);

        // else if (s->front() == '(')
        //     s->pop();

        // else
        //     s->insert(ch);
    }
}

if (s->is_empty())
    cout << "YES\n";
else
    cout << "NO\n";

delete s;
```        
